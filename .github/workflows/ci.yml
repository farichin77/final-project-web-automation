name: Web B2B Dibimbing.id Automation CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        browser: [chrome, edge, firefox]

    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17
          cache: 'gradle'

      - name: Install browsers (NO SNAP)
        run: |
          sudo apt-get update
          sudo apt-get install -y xvfb

          # 1. Setup Firefox via Mozilla PPA
          sudo add-apt-repository -y ppa:mozillateam/ppa
          echo '
          Package: *
          Pin: release o=LP-PPA-mozillateam
          Pin-Priority: 1001
          ' | sudo tee /etc/apt/preferences.d/mozilla-firefox
          sudo apt-get update
          sudo apt-get install -y firefox

          # 2. Install Chrome
          sudo apt-get install -y google-chrome-stable

          # 3. Install Edge Browser
          curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | sudo gpg --dearmor -o /usr/share/keyrings/microsoft.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/edge stable main" | sudo tee /etc/apt/sources.list.d/microsoft-edge.list
          sudo apt-get update
          sudo apt-get install -y microsoft-edge-stable

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Run Tests (${{ matrix.browser }})
        continue-on-error: true
        # Clean build before running to ensure no stale results
        # Use -PtargetTest to run ONLY the specific block from testng.xml (e.g., "Chrome - Web Automation")
        run: |
          # Capitalize browser name for the test name mapping
          BROWSER_NAME="${{ matrix.browser }}"
          DISPLAY_NAME="$(tr '[:lower:]' '[:upper:]' <<< ${BROWSER_NAME:0:1})${BROWSER_NAME:1}"
          TARGET_TEST="$DISPLAY_NAME - Web Automation"
          
          echo "Running Target Test: $TARGET_TEST"
          
          xvfb-run ./gradlew clean test -PtargetTest="$TARGET_TEST" -Dbrowser=${{ matrix.browser }}
          
          # Prepare results for upload
          mkdir -p build/test-results/${{ matrix.browser }}
          
          # Copy XML results if they exist
          if [ -d "build/test-results/test" ]; then
            cp -r build/test-results/test/. build/test-results/${{ matrix.browser }}/ 2>/dev/null || cp -r build/test-results/test/* build/test-results/${{ matrix.browser }}/ || true
            echo "Copied ${{ matrix.browser }} test results"
          else
            echo "No test results found for ${{ matrix.browser }}"
          fi
        env:
          BASE_URL: ${{ secrets.BASE_URL }}
          LOGIN_EMAIL: ${{ secrets.LOGIN_EMAIL }}
          LOGIN_PASSWORD: ${{ secrets.LOGIN_PASSWORD }}

      - name: Upload Test Results (${{ matrix.browser }})
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.browser }}
          path: build/test-results/${{ matrix.browser }}
          retention-days: 1

  notify:
    needs: test
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Download All Test Results
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-*
          path: all-results
          merge-multiple: false

      - name: Consolidate Results and Notify Slack
        run: |
          python3 << 'EOF'
          import xml.etree.ElementTree as ET
          import os
          import json
          import time
          import urllib.request
          
          # Configuration
          results_base_dir = 'all-results'
          browsers = ['chrome', 'edge', 'firefox']
          webhook_url = "${{ secrets.SLACK_WEBHOOK_URL }}"
          
          browser_stats = {}
          
          def parse_testng_xml(xml_path):
              stats = {'total': 0, 'passed': 0, 'failed': 0, 'skipped': 0}
              try:
                  tree = ET.parse(xml_path)
                  root = tree.getroot()
                  
                  testsuites = []
                  if root.tag == 'testsuite':
                      testsuites = [root]
                  else:
                      testsuites = root.findall('.//testsuite')
                  
                  for testsuite in testsuites:
                      testcases = testsuite.findall('.//testcase')
                      if testcases:
                          for testcase in testcases:
                              stats['total'] += 1
                              if testcase.find('failure') is not None or testcase.find('error') is not None:
                                  stats['failed'] += 1
                              elif testcase.find('skipped') is not None:
                                  stats['skipped'] += 1
                              else:
                                  stats['passed'] += 1
                      else:
                          # Fallback to attributes if no testcase elements
                          stats['total'] += int(testsuite.attrib.get('tests', 0))
                          stats['failed'] += int(testsuite.attrib.get('failures', 0))
                          stats['skipped'] += int(testsuite.attrib.get('skipped', 0))
                          stats['passed'] = stats['total'] - stats['failed'] - stats['skipped']
                          
              except Exception as e:
                  print(f"Error parsing {xml_path}: {e}")
              return stats
          
          print("=" * 60)
          print("Scanning for test results...")
          print(f"Results base directory: {os.path.abspath(results_base_dir)}")
          print("=" * 60)
          
          if os.path.exists(results_base_dir):
              print(f"‚úì Directory exists: {results_base_dir}")
              print(f"\nContents of {results_base_dir}:")
              items = os.listdir(results_base_dir)
              if items:
                  for item in sorted(items):
                      item_path = os.path.join(results_base_dir, item)
                      item_type = "DIR" if os.path.isdir(item_path) else "FILE"
                      print(f"  [{item_type}] {item}")
              else:
                  print("  (empty directory)")
              print()
          else:
              print(f"‚ùå ERROR: Directory {results_base_dir} does not exist!")
              print(f"   This may indicate artifacts were not downloaded correctly.")
              print(f"   Check that test jobs uploaded artifacts with pattern 'test-results-*'")
              print()
          
          for browser in browsers:
              # Artifacts are downloaded into subdirectories named 'test-results-{browser}'
              browser_path = os.path.join(results_base_dir, f'test-results-{browser}')
              
              stats = {'total': 0, 'passed': 0, 'failed': 0, 'skipped': 0, 'emoji': ''}
              
              # Set emoji
              if browser == 'chrome': stats['emoji'] = "üîµ"
              elif browser == 'edge': stats['emoji'] = "üü¢"
              elif browser == 'firefox': stats['emoji'] = "üü†"
              
              print(f"\n--- Processing {browser.upper()} ---")
              if os.path.exists(browser_path):
                  print(f"‚úì Directory found: {browser_path}")
                  xml_files = []
                  for root, dirs, files in os.walk(browser_path):
                      for file in files:
                          if file.endswith('.xml'):
                              xml_files.append(os.path.join(root, file))
                  
                  print(f"  Found {len(xml_files)} XML file(s)")
                  
                  if xml_files:
                      for xml_file in xml_files:
                          print(f"  ‚Üí Parsing: {os.path.basename(xml_file)}")
                          file_stats = parse_testng_xml(xml_file)
                          stats['total'] += file_stats['total']
                          stats['passed'] += file_stats['passed']
                          stats['failed'] += file_stats['failed']
                          stats['skipped'] += file_stats['skipped']
                          print(f"    Stats: Total={file_stats['total']}, Pass={file_stats['passed']}, Fail={file_stats['failed']}, Skip={file_stats['skipped']}")
                  else:
                      print(f"  ‚ö†Ô∏è  No XML files found in {browser_path}")
                      print(f"     This browser may not have run tests or results were not generated")
              else:
                  print(f"  ‚ùå Directory not found: {browser_path}")
                  print(f"     Artifact 'test-results-{browser}' may not have been uploaded")
              
              # Always add browser stats, even if total is 0
              browser_stats[browser] = stats
              print(f"  {browser.upper()} Summary: Total={stats['total']}, Pass={stats['passed']}, Fail={stats['failed']}, Skip={stats['skipped']}")
          
          # Prepare Slack Notification
          if not webhook_url or webhook_url == "" or webhook_url == "None":
              print("‚ö†Ô∏è WARNING: SLACK_WEBHOOK_URL is not set in GitHub Secrets.")
              print("   Please configure SLACK_WEBHOOK_URL in repository settings > Secrets and variables > Actions")
              print("   Skipping Slack notification...")
              exit(0)
          
          # Calculate Grand Totals
          total_all = sum(s['total'] for s in browser_stats.values())
          passed_all = sum(s['passed'] for s in browser_stats.values())
          failed_all = sum(s['failed'] for s in browser_stats.values())
          skipped_all = sum(s['skipped'] for s in browser_stats.values())
          browsers_tested = len([b for b, s in browser_stats.items() if s['total'] > 0])
          
          print(f"\n=== Test Results Summary ===")
          print(f"Total Tests: {total_all}")
          print(f"Passed: {passed_all}")
          print(f"Failed: {failed_all}")
          print(f"Skipped: {skipped_all}")
          print(f"Browsers Tested: {browsers_tested}")
          print(f"===========================\n")
          
          # Determine overall result
          if total_all == 0:
              overall_result = "‚ö†Ô∏è NO TESTS RUN"
              summary_color = "warning"
              print("‚ö†Ô∏è Warning: No test results found. This may indicate:")
              print("   - Tests did not execute")
              print("   - Test results were not generated")
              print("   - Artifacts were not uploaded correctly")
          elif failed_all > 0:
              overall_result = "‚ùå OVERALL FAILED"
              summary_color = "danger"
          else:
              overall_result = "‚úÖ PASSED"
              summary_color = "good"
              
          # Build Fields for each browser (always show all browsers)
          fields = []
          for browser in browsers:
              stats = browser_stats.get(browser, {'total': 0, 'passed': 0, 'failed': 0, 'skipped': 0, 'emoji': ''})
              
              # Ensure emoji is set
              if not stats.get('emoji'):
                  if browser == 'chrome': stats['emoji'] = "üîµ"
                  elif browser == 'edge': stats['emoji'] = "üü¢"
                  elif browser == 'firefox': stats['emoji'] = "üü†"
              
              browser_name = browser.capitalize()
              status_icon = "‚ùå" if stats['failed'] > 0 else "‚úÖ"
              if stats['total'] == 0: status_icon = "‚ö†Ô∏è"
              
              value_text = f"Total: {stats['total']} | Pass: {stats['passed']} | Fail: {stats['failed']} | Skip: {stats['skipped']}"
              fields.append({
                  "title": f"{stats['emoji']} {browser_name} {status_icon}",
                  "value": value_text,
                  "short": False
              })
              
          # Add Overall Summary field with better format
          summary_value = f"*Overall Result:* {overall_result}\n"
          summary_value += f"*Total Tests (All Browsers):* {total_all}\n"
          summary_value += f"*Total Passed:* {passed_all}\n"
          summary_value += f"*Total Failed:* {failed_all}\n"
          summary_value += f"*Total Skipped:* {skipped_all}\n"
          summary_value += f"*Browsers Tested:* {browsers_tested}"
          
          fields.append({
              "title": "üìä Overall Summary",
              "value": summary_value,
              "short": False
          })
          
          # Get current date for footer
          from datetime import datetime
          current_date = datetime.now().strftime("%b %d, %Y")
          
          # Always send notification, even if no results (with warning status)
          payload = {
              "attachments": [{
                  "color": summary_color,
                  "pretext": f"*Web B2B Dibimbing.id - Consolidated Summary*",
                  "fields": fields,
                  "footer": f"GitHub Actions - Consolidated Report | {current_date}",
                  "ts": int(time.time())
              }]
          }
          
          print(f"Sending notification to Slack...")
          print(f"Webhook URL configured: {'Yes' if webhook_url else 'No'}")
          
          try:
              data = json.dumps(payload).encode('utf-8')
              req = urllib.request.Request(
                  webhook_url, 
                  data=data, 
                  headers={'Content-Type': 'application/json'}
              )
              
              with urllib.request.urlopen(req, timeout=10) as response:
                  response_code = response.getcode()
                  if response_code == 200:
                      print(f"‚úÖ Notification sent successfully! Status: {response_code}")
                  else:
                      print(f"‚ö†Ô∏è Notification sent but received unexpected status: {response_code}")
                      response_body = response.read().decode('utf-8')
                      print(f"Response: {response_body}")
                      
          except urllib.error.HTTPError as e:
              print(f"‚ùå HTTP Error sending notification: {e.code} - {e.reason}")
              error_body = e.read().decode('utf-8') if e.fp else "No error details"
              print(f"Error details: {error_body}")
              exit(1)
          except urllib.error.URLError as e:
              print(f"‚ùå URL Error sending notification: {e.reason}")
              print(f"   Please verify SLACK_WEBHOOK_URL is correct")
              exit(1)
          except Exception as e:
              print(f"‚ùå Unexpected error sending notification: {type(e).__name__}: {e}")
              import traceback
              print(f"Traceback: {traceback.format_exc()}")
              exit(1)
          EOF